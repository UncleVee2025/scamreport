/// <reference lib="webworker" />

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies"

declare const self: ServiceWorkerGlobalScope

clientsClaim()

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing
const fileExtensionRegexp = /\/[^/?]+\.[^/]+$/
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith("/_")) {
      return false
    }
    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false
    }
    // Return true to signal that we want to use the handler.
    return true
  },
  createHandlerBoundToURL("/index.html"),
)

// Cache images with a Cache First strategy
registerRoute(
  // Check to see if the request's destination is style for stylesheets, script for JavaScript, or image
  ({ request }) => request.destination === "image",
  // Use a Cache First caching strategy
  new CacheFirst({
    // Put all cached files in a cache named 'images'
    cacheName: "images",
    plugins: [
      // Ensure that only 50 images are cached, and they are deleted after 30 days
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 Days
      }),
    ],
  }),
)

// Cache stylesheets and scripts with a Stale While Revalidate strategy
registerRoute(
  ({ request }) => request.destination === "style" || request.destination === "script",
  new StaleWhileRevalidate({
    cacheName: "assets",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 32,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 1 Week
      }),
    ],
  }),
)

// Cache the API responses with a Stale While Revalidate strategy
registerRoute(
  ({ url }) => url.pathname.startsWith("/api/"),
  new StaleWhileRevalidate({
    cacheName: "api-responses",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 32,
        maxAgeSeconds: 60 * 60 * 24, // 1 Day
      }),
    ],
  }),
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting()
  }
})

const CACHE_NAME = "scamreport-namibia-v1"
const OFFLINE_URL = "/offline"

// Add an event listener to install the service worker
self.addEventListener("install", (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(CACHE_NAME)
      // Cache the offline page
      await cache.add(new Request(OFFLINE_URL, { cache: "reload" }))
      // Cache essential assets
      await cache.addAll(["/", "/images/logo.png", "/dashboard", "/login", "/register", "/emergency"])
    })(),
  )
  // Force the waiting service worker to become the active service worker
  self.skipWaiting()
})

self.addEventListener("activate", (event) => {
  event.waitUntil(
    (async () => {
      // Enable navigation preload if it's supported
      if ("navigationPreload" in self.registration) {
        await self.registration.navigationPreload.enable()
      }

      // Clean up old caches
      const cacheNames = await caches.keys()
      await Promise.all(
        cacheNames.filter((cacheName) => cacheName !== CACHE_NAME).map((cacheName) => caches.delete(cacheName)),
      )
    })(),
  )
  // Tell the active service worker to take control of the page immediately
  self.clients.claim()
})

// self.addEventListener("fetch", (event) => {
//   // Only handle GET requests
//   if (event.request.method !== "GET") return

//   // For API requests, use network-first strategy
//   if (event.request.url.includes("/api/")) {
//     event.respondWith(
//       fetch(event.request).catch(() => {
//         return new Response(JSON.stringify({ error: "You are offline" }), {
//           status: 503,
//           headers: { "Content-Type": "application/json" },
//         })
//       }),
//     )
//     return
//   }

//   // For page navigations, use a cache-first strategy
//   if (event.request.mode === "navigate") {
//     event.respondWith(
//       (async () => {
//         try {
//           // First, try to use the navigation preload response if it's supported
//           const preloadResponse = await event.preloadResponse
//           if (preloadResponse) {
//             return preloadResponse
//           }

//           // Always try the network first
//           return await fetch(event.request)
//         } catch (error) {
//           // If the network is unavailable, get from the cache
//           const cache = await caches.open(CACHE_NAME)
//           const cachedResponse = await cache.match(event.request)
//           if (cachedResponse) {
//             return cachedResponse
//           }

//           // If we can't get from the cache, return the offline page
//           return await cache.match(OFFLINE_URL)
//         }
//       })(),
//     )
//     return
//   }

//   // For all other requests, use a stale-while-revalidate strategy
//   event.respondWith(
//     (async () => {
//       const cache = await caches.open(CACHE_NAME)
//       const cachedResponse = await cache.match(event.request)

//       const fetchPromise = fetch(event.request)
//         .then((networkResponse) => {
//           cache.put(event.request, networkResponse.clone())
//           return networkResponse
//         })
//         .catch(() => {
//           // If fetch fails and we don't have a cached response, return a simple offline message
//           if (!cachedResponse) {
//             if (event.request.headers.get("Accept")?.includes("text/html")) {
//               return cache.match(OFFLINE_URL)
//             }
//             return new Response("Offline", { status: 503 })
//           }
//           return cachedResponse
//         })

//       return cachedResponse || fetchPromise
//     })(),
//   )
// })
